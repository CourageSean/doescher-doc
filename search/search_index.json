{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Willkommen zur Tabellen-Software","text":""},{"location":"#executable-downloads","title":"Executable Downloads","text":"<p>Windows: Link text Here</p>"},{"location":"#lokale-entwicklung","title":"Lokale Entwicklung","text":""},{"location":"#voraussetzungen","title":"Voraussetzungen","text":"<p>Bevor Sie beginnen, stellen Sie sicher, dass die folgenden Voraussetzungen erf\u00fcllt sind: .NET 8.0 SDK installiert Git installiert (f\u00fcr das Klonen des Repositories) Anwendung starten Folgen Sie diesen Schritten, um die Anwendung zu starten:</p>"},{"location":"#1-repository-klonen","title":"1. Repository klonen","text":"<p>\u00d6ffnen Sie Ihre Kommandozeile oder Terminal und f\u00fchren Sie den folgenden Befehl aus, um das Repository zu klonen:</p> <p><code>git clone https://github.com/IhrRepository/Tabellen-Software.git</code></p>"},{"location":"#2-in-das-projektverzeichnis-wechseln","title":"2. In das Projektverzeichnis wechseln","text":"<p><code>cd Tabellen-Software</code></p> <p>Wechseln Sie in das Verzeichnis des geklonten Repositories:</p>"},{"location":"#3-anwendung-bauen","title":"3. Anwendung bauen","text":"<p>Bauen Sie die Anwendung mit dem .NET CLI-Tool:</p> <p><code>dotnet build</code></p>"},{"location":"#4-anwendung-ausfuhren","title":"4. Anwendung ausf\u00fchren","text":"<p>Startetn Sie die Anwendung:</p> <p><code>dotnet run --project Tabellen-Software</code></p>"},{"location":"documentation/","title":"Dokumentation f\u00fcr Tabellen-Software","text":"<p>Diese Dokumentation bietet einen \u00dcberblick \u00fcber die Kernkomponenten der AvaloniaApplication, um Entwicklern und Kunden einen schnellen Einstieg und Verst\u00e4ndnis der Anwendung zu erm\u00f6glichen. Die Anwendung besteht aus verschiedenen Views und ViewModels, die zusammenarbeiten, um die Funktionalit\u00e4t der Anwendung zu realisieren.</p>"},{"location":"documentation/#verwendete-technologien","title":"Verwendete Technologien","text":""},{"location":"documentation/#avaloniaui","title":"AvaloniaUI","text":"<p>Ein plattform\u00fcbergreifendes Framework f\u00fcr .NET, ideal f\u00fcr die Entwicklung von Desktop-Anwendungen auf verschiedenen Betriebssystemen. Erlaubt eine flexible Gestaltung der Benutzeroberfl\u00e4che mit XAML und unterst\u00fctzt das MVVM-Muster f\u00fcr eine saubere Trennung von UI und Business-Logik.</p>"},{"location":"documentation/#net-80","title":".NET 8.0","text":"<p>Bietet eine moderne und leistungsf\u00e4hige Entwicklungsumgebung. Nutzt aktuelle C#-Features und stellt eine breite Palette von Bibliotheken zur Verf\u00fcgung, um Entwicklungsprozesse zu optimieren.</p> <p>### CommunityToolkit.Mvvm</p> <p>Vereinfacht die Implementierung des MVVM-Designmusters, unterst\u00fctzt die Entwicklung wartbarer und testbarer Anwendungen durch die Bereitstellung von Hilfsklassen f\u00fcr Bindings, Commands und ObservableProperties.</p>"},{"location":"documentation/#fluentavaloniaui","title":"FluentAvaloniaUI","text":"<p>FluentAvaloniaUI ist eine Bibliothek, die Fluent Design System Komponenten f\u00fcr AvaloniaUI bereitstellt. Es wird verwendet, um der Anwendung ein modernes Aussehen und Gef\u00fchl zu geben.</p>"},{"location":"documentation/#microsoftextensionsdependencyinjection","title":"Microsoft.Extensions.DependencyInjection","text":"<p>Diese Bibliothek wird f\u00fcr die Dependency Injection verwendet, um die Verwaltung von Abh\u00e4ngigkeiten zwischen verschiedenen Teilen der Anwendung zu vereinfachen.</p>"},{"location":"documentation/#communitytoolkitlabsextensionsdependencyinjection","title":"CommunityToolkit.Labs.Extensions.DependencyInjection","text":"<p>Eine Erweiterung f\u00fcr die Dependency Injection, die zus\u00e4tzliche Funktionalit\u00e4ten f\u00fcr die Verwaltung von Services und ViewModels bietet.</p>"},{"location":"documentation/#hauptkomponenten","title":"Hauptkomponenten","text":""},{"location":"documentation/#views","title":"Views","text":"<p>MainWindow: Die Hauptansicht agiert als Container f\u00fcr die anderen Views und setzt ein SplitView-Layout ein, um eine Navigationsleiste von dem Hauptinhalt zu trennen. Beispielcode demonstriert, wie AvaloniaUI f\u00fcr das Layout verwendet wird.</p> MainWindow.axaml<pre><code>     &lt;Grid RowDefinitions=\"Auto, *\"&gt;\n        &lt;Border Grid.Row=\"0\" Height=\"32\"&gt;\n            &lt;TextBlock Text=\"{Binding Title, RelativeSource={RelativeSource FindAncestor, AncestorType=Window }}\"\n                       VerticalAlignment=\"Center\" Margin=\"10 0\"/&gt;\n        &lt;/Border&gt;\n        &lt;SplitView Grid.Row=\"1\"\n                   IsPaneOpen=\"{Binding IsPaneOpen}\"\n                   CompactPaneLength=\"46\"\n                   DisplayMode=\"CompactInline\"\n</code></pre> <p>HomePageView: Dient als Startpunkt der Anwendung und bietet Benutzern die M\u00f6glichkeit, mit der Anwendung zu interagieren, z.B. durch das Hochladen von Dateien. Beispielcode zeigt die Verwendung von Event Bindings und UI-Elementen.</p> HomePageView.axaml<pre><code>            &lt;StackPanel HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"&gt;  \n            &lt;PathIcon Data=\"{StaticResource Arrowuploadregular}\" Margin=\"0 0 0 80\"&gt;&lt;/PathIcon&gt;\n            &lt;/StackPanel&gt;\n            &lt;TextBlock xml:space=\"preserve\" VerticalAlignment=\"Center\"&gt;\n                Verzeichnis hierher ziehen\n                oder zum Hochladen anklicken\n            &lt;/TextBlock&gt;\n        &lt;Canvas x:Name=\"DottedBorderCanvas\" Width=\"300\" Height=\"150\" HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\"&gt;\n        &lt;/Canvas&gt;\n        &lt;/Grid&gt;\n        &lt;/StackPanel&gt;\n            &lt;StackPanel&gt;\n            &lt;/StackPanel&gt;\n        &lt;Button Name=\"CreateTableButton\" Classes=\"tableGenerateButton\" Padding=\"13\" Cursor=\"Hand\" Command=\"{Binding CreateTableCommand}\" HorizontalAlignment=\"Center\"&gt;\n            &lt;StackPanel Orientation=\"Vertical\"&gt;\n                &lt;TextBlock&gt;Tabelle Erstellen&lt;/TextBlock&gt;\n            &lt;/StackPanel&gt; \n        &lt;/Button&gt;\n                 &lt;StackPanel IsVisible=\"{Binding IsTableGeneratedSuccessfully}\" Orientation=\"Horizontal\" HorizontalAlignment=\"Center\"&gt;\n                     &lt;TextBlock Text=\"Die Tabelle wurde erfolgreich generiert.\" FontSize=\"15\" Foreground=\"#107c10\" HorizontalAlignment=\"Center\" Margin=\"0 0 0 10\"/&gt;\n                     &lt;PathIcon Data=\"{StaticResource Openregular}\" Cursor=\"Hand\" VerticalAlignment=\"Top\" PointerPressed=\"OpenFolderIcon_PointerPressed\"&gt;&lt;/PathIcon&gt;\n                 &lt;/StackPanel&gt;\n            &lt;TextBlock Text=\"{Binding ErrorMessage}\"  FontSize=\"15\" TextWrapping=\"Wrap\" Foreground=\"#d83b01\" HorizontalAlignment=\"Center\" Margin=\"0 0 0 10\"/&gt;\n            &lt;TextBlock Text=\"{Binding ErrorMessage}\"  FontSize=\"15\" TextWrapping=\"Wrap\" Foreground=\"#d2d0ce\" HorizontalAlignment=\"Center\" Margin=\"0 0 0 10\"/&gt;\n           &lt;StackPanel Margin=\"20 0\"&gt;\n               &lt;ToggleSwitch IsEnabled=\"{Binding IsButtonEnabled}\"&gt;&lt;/ToggleSwitch&gt;\n                &lt;ToggleSwitch IsEnabled=\"{Binding IsButtonEnabled}\"&gt;&lt;/ToggleSwitch&gt;\n           &lt;/StackPanel&gt;\n</code></pre>"},{"location":"documentation/#viewmodels","title":"ViewModels","text":"<p>Das ViewModel f\u00fcr das MainWindow, das die Logik f\u00fcr die Navigation und das Zustandsmanagement der Anwendung enth\u00e4lt.</p> MainWindowViewModel.cs<pre><code>         [ObservableProperty]\n    private bool _isPaneOpen = false;\n\n    [ObservableProperty] \n    private ViewModelBase _currentPage;\n\n    [ObservableProperty]\n    private ListItemTemplate? _selectedListItem;\n\n    public MainWindowViewModel(IErrorMessageService errorHandlingService, ITableProcessingService tableProcessingService)\n    {\n        _currentPage = new HomePageViewModel(tableProcessingService, errorHandlingService);\n    }\n\n    partial void OnSelectedListItemChanged(ListItemTemplate? value)\n    {\n        if (value is null) return;\n\n        var instance = Design.IsDesignMode\n            ? Activator.CreateInstance(value.ModelType)\n            : Ioc.Default.GetService(value.ModelType);\n</code></pre> <p>Das ViewModel f\u00fcr die HomePageView, das die Logik f\u00fcr das Hochladen von Verzeichnissen, die Erstellung von Tabellen und die Fehlerbehandlung enth\u00e4lt.</p> HomePageViewModel.cs<pre><code>    public partial class HomePageViewModel : ViewModelBase\n    {\n        private IErrorMessageService _errorMessageService;\n        private string _errorMessage = \"\";\n        private string _folderPath = \"Kein Ordner ausgew\u00e4hlt\";\n        private string _notification = \"\";\n        private bool _isFolderPathValid;\n        private bool _isTableGeneratedSuccessfully = false;\n        private readonly ITableProcessingService _tableProcessingService;\n        private readonly IUserNotificationService _notificationService;\n\n        public HomePageViewModel(ITableProcessingService tableProcessingService, IErrorMessageService errorMessageService)\n        {\n            //SetFolderPathCommand = new RelayCommand&lt;string&gt;(SetFolderPath);\n            _errorMessageService = errorMessageService;\n            _tableProcessingService = tableProcessingService;\n        }\n        [ObservableProperty]\n        private bool _isButtonEnabled = true;\n</code></pre>"},{"location":"documentation/#services","title":"Services","text":""},{"location":"documentation/#tabellengenerierung","title":"Tabellengenerierung","text":"<p>Die Tabellengenerierung ist ein zentraler Bestandteil der Anwendung, der es Benutzern erm\u00f6glicht, aus verschiedenen Datenquellen Tabellen zu erstellen. Der Prozess umfasst typischerweise das Einlesen von Daten, deren Verarbeitung und die Ausgabe in einem strukturierten Format.</p> <p>Ein Service, der Fehlermeldungen basierend auf einem Schl\u00fcssel bereitstellt. Wird im HomePageViewModel verwendet, um Benutzerfreundliche Fehlermeldungen anzuzeigen.</p> <p>TableProcessingService.cs<pre><code>public class TableProcessingService : ITableProcessingService\n{\n    public Table GenerateTableFromData(IEnumerable&lt;DataPoint&gt; dataPoints)\n    {\n        var table = new Table();\n        // Konfigurieren der Spalten basierend auf den DataPoint-Eigenschaften\n        table.Columns.Add(new Column(\"ID\", typeof(int)));\n        table.Columns.Add(new Column(\"Wert\", typeof(string)));\n        table.Columns.Add(new Column(\"Datum\", typeof(DateTime)));\n\n        // Bef\u00fcllen der Tabelle mit Daten\n        foreach (var dataPoint in dataPoints)\n        {\n            var row = table.NewRow();\n            row[\"ID\"] = dataPoint.Id;\n            row[\"Wert\"] = dataPoint.Value;\n            row[\"Datum\"] = dataPoint.Timestamp;\n            table.Rows.Add(row);\n        }\n\n        return table;\n    }\n}\n</code></pre> In diesem Beispiel wird eine einfache Methode innerhalb eines TableProcessingService dargestellt, die eine Tabelle aus einer Sammlung von Datenpunkten erstellt. Es illustriert, wie man eine Tabelle mit Spalten definiert und dann Zeilen mit Daten aus den Datenpunkten hinzuf\u00fcgt.</p>"},{"location":"documentation/#graphgenerierung","title":"Graphgenerierung","text":"<p>Die Graphgenerierung erm\u00f6glicht es Benutzern, visuelle Darstellungen ihrer Daten zu erstellen. Dies kann durch die Verwendung von Datenvisualisierungsbibliotheken erfolgen, die in das Projekt integriert sind.</p> GraphDialogViewModel.cs<pre><code> public GraphDialogViewModel(IEnumerable&lt;double&gt; pPmaxValues, IEnumerable&lt;double&gt; generatorValues, double startFreq,\n        double stopFreq, string fileName)\n    {\n        double stepSize = (stopFreq - startFreq) / (pPmaxValues.Count() - 1);\n        var pPmaxPoints = pPmaxValues.Select((value, index) =&gt; new ObservablePoint(startFreq + index * stepSize, value))\n            .ToArray();\n        var generatorPoints = generatorValues\n            .Select((value, index) =&gt; new ObservablePoint(startFreq + index * stepSize, value)).ToArray();\n\n        Series = new ISeries[]\n        {\n            new LineSeries&lt;ObservablePoint&gt;\n            {\n                Values = pPmaxPoints, Name = $\"{fileName} - P/Pmax[%]\", GeometrySize = 0, LineSmoothness = 0\n            },\n            new LineSeries&lt;ObservablePoint&gt;\n            {\n                Values = generatorPoints,\n                Name = $\"{fileName} - Generator[%]\",\n                GeometrySize = 0,\n                LineSmoothness = 0\n            }\n        };\n</code></pre> ErrorMessageService.cs<pre><code> public class ErrorMessageService : IErrorMessageService\n{\n    public string GetErrorMessage(string messageKey)\n    {\n        return messageKey switch\n        {\n            \"notDirectory\" =&gt; \"Die ausgew\u00e4hlte Datei entspricht keinem Verzeichnis. Bitte w\u00e4hlen Sie ein nicht leeres Verzeichnis aus.\",\n            \"InvalidFolderPath\" =&gt; \"Verzeichnis fehlt. Bitte ausw\u00e4hlen.\",\n            // Add more cases here as needed\n            _ =&gt; \"Unbekannter Fehler\"\n        };\n    }\n\n}\n</code></pre> <p>Ein Service, der die Logik f\u00fcr die Verarbeitung von Tabellen enth\u00e4lt. Wird im HomePageViewModel verwendet, um die Hauptlogik der Anwendung auszuf\u00fchren.</p> TableProcessingService.cs<pre><code>    public class TableProcessingService : ITableProcessingService\n     {\n         private IUserNotificationService _userNotificationService;\n        public TableProcessingService(IUserNotificationService userNotificationService)\n        {\n            this._userNotificationService = userNotificationService;\n        }\n        private List&lt;DataPointConfig&gt; dataPointConfigs = new List&lt;DataPointConfig&gt;\n        {\n            new DataPointConfig\n            {\n                Key = \"Zeitpunkt\",\n                Formatter = (value) =&gt; $\"t {value.Substring(0, 10)}_{value.Substring(10).Replace('_', ':')};;\"\n            },\n            // Add more configurations here as needed for other dynamic data points\n        };\n</code></pre>"},{"location":"documentation/#dependency-injection","title":"Dependency Injection","text":"<p>Die Anwendung verwendet Dependency Injection, um die Services und ViewModels zu verwalten. Die Konfiguration erfolgt in App.axaml.cs.</p> App.axaml.cs<pre><code>    [Singleton(typeof(MainWindowViewModel))]\n    [Transient(typeof(HomePageViewModel))]\n    [Transient(typeof(UserNotificationService))]\n    [Transient(typeof(ErrorMessageService))]\n    [Transient(typeof(TableProcessingService))]\n    internal static partial void ConfigureViewModels(IServiceCollection services);\n\n    [Singleton(typeof(MainWindow))]\n    [Transient(typeof(HomePageView))]\n    internal static partial void ConfigureViews(IServiceCollection services);\n</code></pre>"},{"location":"documentation/#architektur-und-designmuster","title":"Architektur und Designmuster","text":"<p>Die Anwendung folgt dem MVVM-Architekturmuster, das eine klare Trennung zwischen der Benutzeroberfl\u00e4che (Views), der Gesch\u00e4ftslogik (ViewModels) und den Diensten (Services) gew\u00e4hrleistet. Diese Struktur f\u00f6rdert Wiederverwendbarkeit, Testbarkeit und Wartbarkeit. Dependency Injection spielt eine Schl\u00fcsselrolle in der Architektur, indem es das Management von Abh\u00e4ngigkeiten zwischen den Komponenten vereinfacht und ihre Kopplung reduziert.</p>"},{"location":"documentation/#navigation","title":"Navigation","text":"<p>Die Navigation innerhalb der Anwendung wird durch das MainWindowViewModel gesteuert, das auf Benutzerinteraktionen reagiert und entsprechend das CurrentPage-Property aktualisiert. Ein Beispielcode-Snippet k\u00f6nnte zeigen, wie die Navigation zwischen verschiedenen Views umgesetzt wird, einschlie\u00dflich der Verwendung von Commands und der Reaktion auf Benutzeraktionen.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#hier-ensteht-ein-tutorial-zur-anwendung","title":"Hier ensteht ein Tutorial zur Anwendung","text":""},{"location":"zeiterfassung/","title":"Zeiterfassung","text":"Zeitraum Stunden Was 06.02.24 - 11.02.24 5 Recherche, Dokumentationen lesen, Entwicklungsumgebung aufsetzen 12.02.24 - 18.02.24 10 Pipeline aufsetzen, TableprocessServiceentwicklung 19.02.24 - 25.02.24 10 TableprocessServiceentwicklung, Rekursionsverarbeitung fixen 26.02.24 - 29.02.24 5 Meeting, Rekursionsverarbeitung Entwicklung, GrapheFramwork-dokumentation 01.03.24 - 10.03.24 18 Meeting, Graph-plot funktionalit\u00e4t, Tabellen-graph 11.03.24 - 21.03.24 11 Tabelle-graph Erweiterungsfunktion, L\u00f6schfunktion, refactor 22.03.24 - 30.03.24 6 Meeting Vorort, style updates, debugging 31.03.24 - 07.04.24 10 Graphen aus Tabelle(multi) plotten, crosshair funktionalit\u00e4t, designanpassungen, 08.04.24 - 14.04.24 15 Dynamische L\u00f6schung, live chart 2 Dokumenation,debugging 15.04.24 - 21.04.24 6 Meeting, style updates, update view funktionalit\u00e4t, stehts renderer \u00fcber ordnerhirarchie"}]}